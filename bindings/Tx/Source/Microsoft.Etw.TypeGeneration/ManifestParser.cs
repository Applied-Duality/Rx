namespace Microsoft.Etw
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Xml.Linq;
    using System.Text.RegularExpressions;
    using Microsoft.CSharp;
    using System.Globalization;

    public class ManifestParser
    {
        public static Dictionary<string, string> Parse(string manifest)
        {
            ManifestParser parser = new ManifestParser(manifest);
            return parser._code;
        }

        XElement _root;
        XElement _instrumentation;
        XElement _events;
        IEnumerable<XElement> _providers;
        XElement _stringTable;
        Dictionary<string, string> _code;
        static CSharpCodeProvider _provider = new CSharpCodeProvider();

        public ManifestParser(string manifest)
        {
            XElement localization;
            XElement resources;
            
            _root = XElement.Parse(manifest);
            _instrumentation = _root.Element(ElementNames.Instrumentation);
            if (_instrumentation == null)
            {
                _instrumentation = _root.Element(ElementNames.Instrumentation1);
                localization = _root.Element(ElementNames.Localization1);
                resources = localization.Element(ElementNames.Resources1);
                _stringTable = resources.Element(ElementNames.StringTable1);
            }
            else
            {
                localization = _root.Element(ElementNames.Localization);
                resources = localization.Element(ElementNames.Resources);
                _stringTable = resources.Element(ElementNames.StringTable);
            }
            _events = _instrumentation.Element(ElementNames.Events);
            _providers = _events.Elements(ElementNames.Provider);

            _code = new Dictionary<string, string>();


            foreach (XElement provider in _providers)
            {
                // Itis unusual that the source attribute is missing. I send mail to Vance
                string source = provider.Attribute(AttributeNames.Source) == null ?
                    "Xml" : provider.Attribute(AttributeNames.Source).Value;

                switch (source)
                {
                    case "Xml":
                        ParseManifestProvider(provider);
                        break;

                    case "Wbem":
                        ParseClassicProvider(provider);
                        break;

                    default:
                        throw new Exception(
                            String.Format("unknown source attribute {0} for provider {1}. The expexted values are Xml and Wbem",
                                source,
                                provider.Attribute(AttributeNames.Name).Value));
                }
            }
        }

        void ParseManifestProvider(XElement provider)
        {
            string providerName = MakeIdentifier(provider.Attribute(AttributeNames.Name).Value);
            string providerGuid = provider.Attribute(AttributeNames.Guid).Value;

            GetEarliestVersions(provider);
            var nameFunction = FindNameFunction(provider);

            XElement events = provider.Element(ElementNames.Events);    
            XElement templates = provider.Element(ElementNames.Templates);
        
            StringBuilder sb = new StringBuilder(
@"// 
//    This code was generated by EtwEventTypeGen.exe 
//

using System;");
            sb.AppendLine();
            sb.AppendLine(); 
            sb.Append("namespace Microsoft.Etw.");
            sb.Append(providerName);
            sb.AppendLine(); 
            sb.AppendLine("{");

            foreach (XElement evt in events.Elements())
            {
                string className = nameFunction(evt);
                string version = "0";
                if (evt.Attribute(AttributeNames.Version) != null)
                {
                    version = evt.Attribute(AttributeNames.Version).Value;
                }

                sb.AppendFormat("    [ManifestEvent(\"{0}\", {1}, {2})]",
                    providerGuid,
                    evt.Attribute(AttributeNames.Value).Value,
                    version);
                sb.AppendLine();

                if (evt.Attribute(AttributeNames.Message) != null)
                {
                    string format = EscapeFormatString(evt.Attribute(AttributeNames.Message).Value);
                    sb.Append("    [Format(\"");
                    sb.Append(format);
                    sb.AppendLine("\")]");
                }

                sb.AppendFormat("    public class {0}{1} : SystemEvent", className, VersionSuffix(evt));
                sb.AppendLine();
                sb.AppendLine("    {");

                EmitTemplate(ref sb, evt, templates);

                sb.AppendLine("    }");
                sb.AppendLine();
            }
            sb.AppendLine("}");

            _code.Add(providerName, sb.ToString());
        }

        void ParseClassicProvider(XElement provider)
        {
            string providerName = MakeIdentifier(provider.Attribute(AttributeNames.Name).Value);
            string providerGuid = provider.Attribute(AttributeNames.Guid).Value;   
            XElement templates = provider.Element(ElementNames.Templates);

            GetEarliestVersions(provider);
            var nameFunction = FindNameFunction(provider);

            XElement events = provider.Element(ElementNames.Events);
            XElement tasks = provider.Element(ElementNames.Tasks);
            XElement opcodes = provider.Element(ElementNames.Opcodes);

            StringBuilder sb = new StringBuilder(
@"// 
//    This code was generated by EtwEventTypeGen.exe 
//

using System;");
            sb.AppendLine();
            sb.AppendLine();
            sb.Append("namespace Microsoft.Etw.");
            sb.Append(providerName);
            sb.AppendLine();
            sb.AppendLine("{");

            foreach (XElement evt in events.Elements())
            {
                string className = nameFunction(evt);

                XElement task = (from t in tasks.Elements()
                                where evt.Attribute(AttributeNames.Task).Value == t.Attribute(AttributeNames.Name).Value
                                select t).First();

                XElement opcode = (from o in opcodes.Elements()
                                   where evt.Attribute(AttributeNames.Opcode).Value == o.Attribute(AttributeNames.Name).Value
                                   select o).First();

                string version = "0";
                if (evt.Attribute(AttributeNames.Version) != null)
                {
                    version = evt.Attribute(AttributeNames.Version).Value;
                }

                sb.AppendFormat("    [ClassicEvent(\"{0}\", {1}, {2})]",
                    task.Attribute(AttributeNames.EventGuid).Value,
                    opcode.Attribute(AttributeNames.MofValue).Value,
                    version);

                sb.AppendLine();

                sb.AppendFormat("    public class {0}{1} : SystemEvent", className, VersionSuffix(evt));
                sb.AppendLine();
                sb.AppendLine("    {");

                EmitTemplate(ref sb, evt, templates);

                sb.AppendLine("    }");
                sb.AppendLine();
            }
            sb.AppendLine("}");

            _code.Add(providerName, sb.ToString());
        }

        string MakeIdentifier(string name)
        {
            // I stumbled on case of using field name like "load/unload"...
            char[] chars = name.ToCharArray();
            for (int i = 0; i < chars.Length; i++)
            {
                if (!char.IsLetterOrDigit(chars[i]))
                {
                    chars[i] = '_';
                }
            }
            return new string(chars);
        }

        void EmitTemplate(ref StringBuilder sb, XElement evt, XElement templates)
        {
            if (evt.Attribute(AttributeNames.Template) == null)
                return;

            var template = from t in templates.Elements()
                            where t.Attribute(AttributeNames.Tid).Value == evt.Attribute(AttributeNames.Template).Value
                            select t;

            int order = 0;
            foreach (var f in template.Elements(ElementNames.Data))
            {
                if (order>0)
                    sb.AppendLine(); 

                sb.AppendFormat("        [EventField(\"{0}\")]",
                    f.Attribute(AttributeNames.InType).Value);
                sb.AppendLine();

                sb.AppendFormat("        public {0} {1}",
                    CleanType(f.Attribute(AttributeNames.InType).Value),
                    CreateIdentifier(f.Attribute(AttributeNames.Name).Value));

                sb.AppendLine(" { get; set; }");
                order++;
            }
        }

        Dictionary<int, XElement> _earliestVersions;

        void GetEarliestVersions(XElement provider)
        {
            _earliestVersions = new Dictionary<int, XElement>();
            XElement events = provider.Element(ElementNames.Events);

            foreach (XElement evt in events.Elements())
            {
                int id = IntAttribute(evt, AttributeNames.Value);

                XElement other;
                if (!_earliestVersions.TryGetValue(id, out other))
                {
                    _earliestVersions.Add(id, evt);
                    continue;
                }

                int version = IntAttribute(evt, AttributeNames.Version);
                int earliestVersion = IntAttribute(other, AttributeNames.Version);
                if (version < earliestVersion)
                {
                    _earliestVersions[id] = evt;
                }
            }
        }

        int IntAttribute(XElement element, XName attributeName)
        {
            XAttribute attribute = element.Attribute(attributeName);
            if (attribute == null)
                return 0;

            string s = attribute.Value;
            if (s.StartsWith("0x"))
            {
                string v = s.Substring(2);
                return int.Parse(v, NumberStyles.AllowHexSpecifier);
            }
            else
            {
                return int.Parse(s);
            }
        }

        string VersionSuffix(XElement evt)
        {
            if (evt.Attribute(AttributeNames.Version) == null)
                return "";

            int id = IntAttribute(evt, AttributeNames.Value);
            int version = IntAttribute(evt, AttributeNames.Version);
            int earliestVersion = IntAttribute(_earliestVersions[id], AttributeNames.Version);

            if (version == earliestVersion)
                return "";

            return "_V" + version;
        }

        Func<XElement, string> FindNameFunction(XElement provider)
        {
            Func<XElement, string> function = e =>
                e.Attribute(AttributeNames.Symbol) != null ? 
                    e.Attribute(AttributeNames.Symbol).Value 
                    : null;

            var names = from e in _earliestVersions.Values select function(e);

            if (AreNamesUseful(names.ToArray()))
            {
                return function;
            }

            XElement opcodes = provider.Element(ElementNames.Opcodes);

            function = e => LookupOpcodeName(e, opcodes);

            names = from e in _earliestVersions.Values select function(e);
            if (AreNamesUseful(names.ToArray()))
            {
                return function;
            }

            XElement tasks = provider.Element(ElementNames.Tasks);

            function = e => LookupTaskName(e, tasks);

            names = from e in _earliestVersions.Values select function(e);
            if (AreNamesUseful(names.ToArray()))
            {
                return function;
            }

            function = e => e.Attribute(AttributeNames.Task)==null?
                            null : e.Attribute(AttributeNames.Task).Value;

            names = from e in _earliestVersions.Values select function(e);
            if (AreNamesUseful(names.ToArray()))
            {
                return function;
            }

            function = e => LookupTaskName(e, tasks) + "_" + 
                (e.Attribute(AttributeNames.Opcode) == null ? 
                "" : e.Attribute(AttributeNames.Opcode).Value.Replace("win:",""));
            names = from e in _earliestVersions.Values select function(e);
            if (AreNamesUseful(names.ToArray()))
            {
                return function;
            }

            function = e => LookupTaskName(e, tasks) + "_"
                + (e.Attribute(AttributeNames.Opcode) == null ?
                    "" : e.Attribute(AttributeNames.Opcode).Value.Replace("win:", ""))
                + "_" + e.Attribute(AttributeNames.Value).Value;

            names = from e in _earliestVersions.Values select function(e);
            if (AreNamesUseful(names.ToArray()))
            {
                return function;
            }

            // could not find useful heuristics
            // so, generate default names
            function = e => "Event_" 
                + e.Attribute(AttributeNames.Value).Value 
                + "_V" + e.Attribute(AttributeNames.Version).Value;

            return function;
        }

        bool AreNamesUseful(string[] names)
        {
            for (int index=0; index<names.Length; index++)
            {
                string name = names[index];

                if (String.IsNullOrEmpty(name))
                {
                    return false;
                }

                // names must be valid identifiers
                if (!Regex.IsMatch(name, "^[A-Z_a-z][A-Z_a-z0-9]+"))
                {
                    return false;
                }

                // there should be no duplicate names
                for (int other = index+1; other < names.Length; other++ )
                {
                    if (name == names[other])
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        string LookupOpcodeName(XElement evt, XElement opcodes)
        {
            if (opcodes == null)
                return null;

            var message = (from o in opcodes.Elements()
                         where
                            evt.Attribute(AttributeNames.Opcode) != null &&
                            evt.Attribute(AttributeNames.Opcode).Value == o.Attribute(AttributeNames.Name).Value
                         select o.Attribute(AttributeNames.Message).Value).FirstOrDefault();
            
            if (String.IsNullOrEmpty(message))
                return null;

            return LookupResourceString(message);
        }

        string LookupTaskName(XElement evt, XElement tasks)
        {
            if (tasks == null)
                return null;

            var message = (from t in tasks.Elements()
                           where 
                               t.Attribute(AttributeNames.Message)!= null &&
                               evt.Attribute(AttributeNames.Task)!= null &&
                               evt.Attribute(AttributeNames.Task).Value == t.Attribute(AttributeNames.Name).Value
                           select t.Attribute(AttributeNames.Message).Value).FirstOrDefault();

            if (String.IsNullOrEmpty(message))
                return null;

            return LookupResourceString(message);
        }

        string LookupResourceString(string message)
        {
            var stringId = message.Substring(9)   // skip "$(string."
                      .TrimEnd(')');

            return (from s in _stringTable.Elements() 
                    where s.Attribute(AttributeNames.Id).Value == stringId
                    select s.Attribute(AttributeNames.Value).Value)
                    .FirstOrDefault();
        }

        string EscapeFormatString(string message)
        {
            string format = LookupResourceString(message);

            return format
                .Replace("\\", "\\\\")
                .Replace("\"", "\\\"");
        }

        string CreateIdentifier(string s)
        {
            char[] chars = s.ToCharArray();
            for (int i = 0; i < chars.Length; i++)
            {
                if (!char.IsLetterOrDigit(chars[i]))
                {
                    chars[i] = '_';
                }
            };

           return _provider.CreateValidIdentifier(new string(chars));
        }

        internal static string CleanType(string typeName)
        {
            switch (typeName)
            {
                case "win:Pointer":
                case "trace:SizeT":
                    return "ulong"; // Address in the VS generation code

                case "win:Boolean":
                    return "bool";

                case "win:Int8":
                    return "sbyte";

                case "win:UInt8":
                    return "byte";

                case "win:HexInt8":
                    return "uint";

                case "win:Int16":
                    return "short";

                case "win:UInt16":
                case "win:HexInt16":
                case "trace:Port":
                    return "ushort";

                case "win:Int32":
                    return "int";

                case "win:UInt32":
                case "win:HexInt32":
                case "trace:IPAddr":
                case "trace:IPAddrV4":
                    return "uint";

                case "win:Double":
                    return "double";

                case "win:Float":
                    return "float";

                case "win:Int64":
                    return "long";

                case "win:SYSTEMTIME":
                    return "DateTime";

                case "trace:WmiTime":
                case "win:FILETIME":
                    return "DateTime";

                case "win:HexInt64":
                case "win:UInt64":
                    return "ulong";

                case "trace:UnicodeChar":
                    return "string";

                case "win:UnicodeString":
                case "win:UnicodeStringPref":
                    return "string";

                case "win:AnsiString":
                case "win:AnsiStringPref":
                    return "string";

                case "win:GUID":
                case "trace:WBEMSid":
                    return "Guid";

                case "win:Binary":
                    return "byte[]";

                case "win:SID":
                    return "string";

                default:
                    throw new InvalidOperationException("unknown type " + typeName);

            }
        }

        class ElementNames
        {
            static readonly XNamespace ns1 = "urn:schemas-microsoft-com:asm.v3";
            public static readonly XName Instrumentation1 = ns1 + "instrumentation";
            public static readonly XName Localization1 = ns1 + "localization";
            public static readonly XName Resources1 = ns1 + "resources";
            public static readonly XName StringTable1 = ns1 + "stringTable";

            static readonly XNamespace ns = "http://schemas.microsoft.com/win/2004/08/events";
            public static readonly XName Instrumentation = ns + "instrumentation";
            public static readonly XName Provider = ns + "provider";
            public static readonly XName Events = ns + "events";
            public static readonly XName Tasks = ns + "tasks";
            public static readonly XName Templates = ns + "templates";
            public static readonly XName Opcodes = ns + "opcodes";
            public static readonly XName Localization = ns + "localization";
            public static readonly XName Resources = ns + "resources";
            public static readonly XName StringTable = ns + "stringTable";
            public static readonly XName Data = ns + "data";
        }

        class AttributeNames
        {
            public const string Source = "source";
            public const string Name = "name";
            public const string Guid = "guid";
            public const string Value = "value";
            public const string Symbol = "symbol";
            public const string Task = "task";
            public const string Template = "template";
            public const string Tid = "tid";
            public const string InType = "inType";
            public const string Version = "version";
            public const string Opcode = "opcode";
            public const string Id = "id";
            public const string Message = "message";
            public const string EventGuid = "eventGUID";
            public const string MofValue = "mofValue";
        }
    }
}
